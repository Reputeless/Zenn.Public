---
title: "標準入出力"
free: true
---

## 1. 標準出力 | std::cout
- 読み方: シーアウト
	- character output
- `<iostream>` ヘッダに含まれる

### 1.1. 概要
- `std::cout` は標準出力ストリームに関連付けられたグローバルオブジェクト
- `std::cout` に対して `<<` 演算子を使って「出力可能な型」の値を送ると、その値が標準出力に出力される
- 出力時に改行は自動では行われない。改行したい場合は改行文字 `'\n'` を出力する
- `<<` を連続して使用し、複数の値を出力することができる

```cpp
#include <iostream>
#include <string>

int main()
{
	int a = 222;
	std::string s = "hello";

	std::cout << 111 << ' ' << a << '\n';
	std::cout << s << '\n';
	std::cout << "world\n";
}
```

### 1.2 出力可能な型
- デフォルトで `std::cout` に対して `<<` 演算子を使える型は限られる
	- 基本型のうち、`bool`, `char`, `signed char`, `unsigned char`, `short`, `unsigned short`, `int`, `unsigned int`, `long`, `unsigned long`, `long long`, `unsigned long long`, `float`, `double`, `long double`, `std::nullptr_t`
	- ポインタ型
	- 標準ライブラリのうち、`std::string`, `std::bitset`, `std::string_view` など
- タプルやコンテナの多くは、標準ではそのまま出力できない
	- ループなどを使って要素を個別に出力する必要がある


### 1.3 出力形式が特殊な型
- `bool` 型
	- `false` → `0`, `true` → `1` のように数字として出力される
	- `std::boolalpha` マニピュレータを使うことで `false` と `true` を出力できる
- `char`, `signed char`, `unsigned char` 型
	- ASCII 表に基づいて、整数の代わりに文字が出力される
	- 印字できない範囲の文字（制御文字など）を出力すると、何も表示されないか、文字化けのような記号が表示される
- `char*`, `signed char*`, `unsigned char*` 型
	- 先頭の要素からヌル終端文字まで文字列として出力される
- 浮動小数点数型（`float`, `double`, `long double`）
	- デフォルトでは小数部と整数部合わせて有効桁が 6 桁程度に収まるよう調整される
	- 表示桁数によっては指数表記になる
	- 問題設定によっては、小数点以下を指定桁数表示することが求められるケースがある
		- マニピュレータ `std::fixed`, `std::setprecision(n)` を組み合わせて対処する
- ポインタ型
	- ポインタの値（メモリアドレス）が出力される

### 1.4 標準出力のコスト
- 標準出力の処理は、一般的な計算処理よりもコストが大きい
- さらに、`std::cout` はデフォルトで C 言語の出力関数 `printf` とバッファを同期するなど、内部状態の管理関連で追加のオーバーヘッドが発生する
- 競技プログラミングのように、短い実行時間や大量の入出力が求められる環境では、C++ の標準出力 `std::cout` をそのまま使うと、相対的に実行時間を大きく消費することがある
	- 「3. 標準入出力の高速化」で述べる方法で、ある程度の高速化が可能

### 1.5 バッファリングとフラッシュ
- `std::cout` は、表示する内容を、まず内部で確保している配列に蓄積し、一定量たまったらその内容をまとめて出力する
	- それぞれ「バッファリング」、「フラッシュ」と呼ぶ
		- `std::cout << std::flush;` で明示的にフラッシュできる
		- `std::cout << std::endl;` は「改行文字の出力 + フラッシュ」で `std::cout << '\n' << std::flush;` と同じ
	- バッファリングのおかげで、頻繁に `std::cout` を使った場合の効率が向上する
- プログラムが終了するときには、必ず自動的にフラッシュが行われる
- 競技プログラミングでは、フラッシュが行われないと出力がジャッジされない
	- プログラム終了時の自動フラッシュがあるため、通常の問題ではフラッシュを意識する必要はない
	- 頻繁にフラッシュをすると、実行時間が遅くなる
- コンテストによっては、複数のプログラム間で通信する形式の問題（「コミュニケーション」あるいは「インタラクティブ」形式と呼ばれる）がある
	- この場合、提出プログラムの途中で明示的にフラッシュしないと、他のプログラムに出力が送信されず、通信が進行不能になる
	- 「コミュニケーション」形式の問題では、`std::flush` または `std::endl` を使って、必ずフラッシュする必要がある


## 2. 標準入力 | std::cin
- 読み方: シーイン
	- character input
- `<iostream>` ヘッダに含まれる

### 2.1. 概要
- `std::cin` は標準入力ストリームに関連付けられたグローバルオブジェクト
- `std::cin` から `>>` 演算子を「入力可能な型」の変数に向けると、その変数に標準入力からの値が格納される


### 2.2 入力可能な型
- デフォルトで `std::cin` からの `>>` 演算子を使える型は限られる



### 2.3 標準入力のコスト
- 標準入力の処理は、一般的な計算処理よりもコストが大きい
- 競技プログラミングのように、短い実行時間や大量の入出力が求められる環境では、C++ の標準入力 `std::cin` をそのまま使うと、相対的に実行時間を大きく消費することがある
	- 「3. 標準入出力の高速化」で述べる方法で、ある程度の高速化が可能


## 3. 標準入出力の高速化

```cpp
#include <iostream>

int main()
{
	std::cin.tie(nullptr);
	std::ios_base::sync_with_stdio(false);
	
	// 以降に標準入出力
}
```

- 次のように 1 行に短くまとめて書くこともできる

```cpp
#include <iostream>

int main()
{
	std::cin.tie(0)->sync_with_stdio(0);
	
	// 以降に標準入出力
}
```


## 4. マニピュレータ

### 4.1 フラッシュする | `std::flush`
- 読み方: フラッシュ
- `<iostream>` ヘッダに含まれる

### 4.2 改行を出力してフラッシュする | `std::endl`
- 読み方: エンドエル
- `<iostream>` ヘッダに含まれる

### 4.3 bool 型を文字列で出力するようにする | `std::boolalpha`
- 読み方: ブールアルファ
- `<ios>` ヘッダに含まれる

### 4.4 浮動小数点数の出力精度を設定する | `std::setprecision(n)`
- 読み方: セットプレシジョン
- `<iomanip>` ヘッダに含まれる

### 4.5 浮動小数点数の出力形式を固定小数点にする | `std::fixed`
- 読み方: フィクスト
- `<ios>` ヘッダに含まれる



## 5. 標準エラー出力 | `std::clog`, `std::cerr`
- 読み方: シーログ, シーエラー
	- character log, character error
- `<iostream>` ヘッダに含まれる

### 5.1. 概要
- `std::clog` および `std::cerr` は標準エラー出力ストリームに関連付けられたグローバルオブジェクト
-  `<<` 演算子を使って「出力可能な型」の値を送ると、その値が標準エラー出力に出力される
- 通常、標準エラー出力はジャッジの対象外となるため、標準出力で解答を出力する一方で、デバッグ情報を標準エラー出力することで、ジャッジに影響を与えずに追加の情報を確認できる


### 5.2 標準エラー出力のコスト
- 標準エラー出力の処理は、標準出力と同様に、一般的な計算処理よりもコストが大きい
- TLE を防ぐために、最終的な提出プログラムでは、標準エラー出力を行うコードは除去またはコメントアウトすることが望ましい

